#!/usr/bin/env ruby

################################################################################
# MmToolCli
#  This file constitutes the command line interface for mm_tool.
###############################################################################

require 'fileutils'
require 'tty-screen'
require 'pastel'
require_relative '../lib/mm_tool'


module MmTool

  #=============================================================================
  # Private, self-contained methods that we will use in the MmToolCliClass,
  # that help in providing legible output on the command line.
  #=============================================================================
  module MmToolCliOutputHelpers

    private

    #------------------------------------------------------------
    # Return an array of argument groups for the given
    # application.
    #------------------------------------------------------------
    def argument_groups(application)
      application.options.collect { |i| i[1] }
          .collect { |i| i[:help_group] }
          .uniq
    end


    #------------------------------------------------------------
    # Given an argument value, return it in a format suitable
    # for output. In general, this means that we want to format
    # array values in the way we expect to receive them as
    # arguments on the command line.
    #------------------------------------------------------------
    def format_value(value)
      if value.instance_of?(Array)
        value.join(',')
      else
        value
      end
    end


    #------------------------------------------------------------
    # Given an application's argument, format the argument for
    # display in help output. Optionally specify the entire
    # width of the argument in order to right-pad it with spaces
    # and/or truncate it to the given width.
    #------------------------------------------------------------
    def format_argument(argument, width = 0 )
      s = argument[:arg_short] ? "#{argument[:arg_short]}," : nil
      l = argument[:arg_format] ? "#{argument[:arg_long]} #{argument[:arg_format]}" : "#{argument[:arg_long]}"
      f = " %-3s %s   " % [s, l]
      if width > 0
        "%-#{width}.#{width}s" % f
      else
        f
      end
    end


    #------------------------------------------------------------
    # Find the length of the longest argument label, including
    # all desired padding, for the provided application.
    #------------------------------------------------------------
    def longest_arg_length(application)
      application.options.collect { |i| i[1] }
          .collect { |i| format_argument(i).length }
          .max
    end


    #------------------------------------------------------------
    # Return a string: with a hanging indent of hang: and a
    # right margin of margin:.
    #------------------------------------------------------------
    def hanging_string( string:, hang: 0, margin: 78 )
      indent_spaces = " " * hang
      result = []

      # Each individual paragraph should end with two newlines; therefore convert
      # individual newlines into spaces, and break the paragraphs into a split.
      string.gsub(/\n\n/, "\f").gsub(/\n/, " ").split(/\f/).each do |line|

        buffer = ''
        line.split(/\s/).each do |word|

          word = ' ' if word.length == 0

          len_buffer = buffer.gsub(/\e\[([;\d]+)?m/, '').length

          if len_buffer == 0 || buffer[-1] == ' '
            added_word = word
          else
            added_word = ' ' + word
          end

          len_word = added_word.gsub(/\e\[([;\d]+)?m/, '').length

          width = result.count == 0 ? margin : margin - hang

          if len_buffer + len_word <= width
            buffer = buffer + added_word
          else
            if result.count == 0
              result << buffer + "\n"
            else
              result << indent_spaces + buffer + "\n"
            end
            buffer = word
          end

        end # line

        if result.count == 0
          result << buffer + "\n\n"
        else
          result << indent_spaces + buffer + "\n\n"
        end

      end

      result.join[0...-1]
    end


  end # module MmToolCliOutputHelpers


  #=============================================================================
  # The MmToolCli class implements the command line interface for
  # MmTool::ApplicationMain
  #=============================================================================
  #noinspection RubyResolve
  class MmToolCli

    include MmToolCliOutputHelpers

    #------------------------------------------------------------
    # Designated initializer.
    #------------------------------------------------------------
    def initialize(app_instance = MmTool::ApplicationMain.sharedApplication)
      @app    = app_instance
      @pastel = Pastel.new(enabled: $stdout.tty? && $stderr.tty?)
    end


    #------------------------------------------------------------
    # Property accessor
    #------------------------------------------------------------
    def app
      @app
    end


    #------------------------------------------------------------
    # Property accessor
    #------------------------------------------------------------
    def c
      @pastel
    end


    #------------------------------------------------------------
    # Print Help
    #------------------------------------------------------------
    #noinspection RubyResolve
    def print_help
      # Gather the basic dimensions required for output.
      # Support a minimum width of 60, which is reasonable, and
      # allow enough room to spacing around the longest argument.
      width    = [TTY::Screen.width, 61].max - 1
      hang_arg = longest_arg_length(app)

      header = <<~HEREDOC
        #{c.bold('Usage:')} #{File.basename($0)} [options...] <directory|file> [options...] <directory|file> ...
        
        Peforms media analysis and reports on files that don't meet quality requirements and/or files that
        have containers and/or streams of undesired types. Files with undesired containers and/or streams
        can optionally be transcoded into a new file.
        
        You must specify a file or a directory. Specifying a directory implies a recursive search for files
        matching the #{c.bold('--container-extension')} option.
  
        Options and files are processed as they occur, and remain in effect for subsequent input files until
        encountered again with a different value. Boolean flags shown below modify default behavior. They
        can be undone for subsequent input files with the capitalized version of the short flag, or by adding
        or deleting #{c.bold('no-')} for the verbose argument form.
      HEREDOC

      puts hanging_string(string: header, hang: 3, margin: width)

      argument_groups(app).each do |group|

        puts "\n#{c.bold(group)}\n\n"

        app.options.select { |option| app.options[option][:help_group] == group }
            .each do | argument, attributes |

          arg = "#{format_argument(attributes, hang_arg)}#{attributes[:help_desc]}" % format_value(app[argument])
          puts hanging_string(string: arg, hang: hang_arg, margin: width) + "\n"

        end # do
      end # each group
    end # print_help


    #------------------------------------------------------------
    # Run the CLI.
    #------------------------------------------------------------
    def run(args)

      path = nil
      while args.count > 0 do

        # Convert single hyphen arguments to one or more multi-hyphen
        # arguments. Doing this as an extra step eliminates redundancy,
        # but also allows -abc in place of -a -b -c.
        if args[0] =~ /^-[A-Za-z]+$/

          args[0][1..-1].reverse.each_char do |char|

            case char

            when "h"
              args.insert(1, "--help")
            when "d"
              args.insert(1, "--drop-subs")
            when "D"
              args.insert(1, "--no-drop-subs")
            when "s"
              args.insert(1, "--skip-boring-files")
            when "S"
              args.insert(1, "--no-skip-boring-files")
            when "t"
              args.insert(1, "--transcode")
            when "T"
              args.insert(1, "--no-transcode")
            when "u"
              args.insert(1, "--no-fix-undefined-language")
            when "U"
              args.insert(1, "--fix-undefined-language")
            when "v"
              args.insert(1, "--verbose")
            when "V"
              args.insert(1, "--no-verbose")
            when "w"
              args.insert(1, "--no-quality-reports ")
            when "W"
              args.insert(1, "--quality-reports ")
            when "x"
              args.insert(1, "--xml")
            when "X"
              args.insert(1, "--no-xml")
            else
              print_arg_error("Error: option #{c.bold(args[0])} was specified, but I don't know that that means.")
            end

          end

          args.shift
          next
        end


        # The main loop processes options, commands, and files in first-in,
        # first out order, which is the normal Unix way compared to how
        # Ruby scripts try to handle things.
        case args[0]


        #-----------------------
        # Main Options
        #-----------------------

        when '--help'
          self.print_help
          exit 0

        when '--containers'
          app[:container_files] = validate_arg_value(args[0], args[1]).split(',')
          args.shift

        when '--skip-boring-files'
          app[:skip_boring] = true

        when '--no-skip-boring-files'
          app[:skip_boring] = false

        when '--verbose'
          app[:verbose] = true

        when '--no-verbose'
          app[:verbose] = false

        when '--version'
          puts "#{File.basename $0}, version #{MmTool::VERSION}"

        when '--xml'
          app[:xml] = true

        when '--no-xml'
          app[:xml] = false

        when '--'
          break

        #-----------------------
        # Media
        #-----------------------

        when '--containers-preferred'
          app[:containers_preferred] = validate_arg_value(args[0], args[1]).split(',')
          args.shift

        when '--codec-audio-preferred'
          app[:codec_audio_preferred] = validate_arg_value(args[0], args[1]).split(',')
          args.shift

        when '--codec-video-preferred'
          app[:codec_video_preferred] = validate_arg_value(args[0], args[1]).split(',')
          args.shift

        when '--codec-subs-preferred'
          app[:codec_subs_preferred] = validate_arg_value(args[0], args[1]).split(',')
          args.shift

        when '--keep-langs-audio'
          app[:keep_langs_audio] = validate_arg_value(args[0], args[1]).split(',')
          args.shift

        when '--keep_langs_video'
          app[:keep_langs_video] = validate_arg_value(args[0], args[1]).split(',')
          args.shift

        when '--keep-langs-subs'
          app[:keep_langs_subs] = validate_arg_value(args[0], args[1]).split(',')
          args.shift

        #-----------------------
        # Transcoding
        #-----------------------

        when '--transcode'
          app[:transcode] = true

        when '--no-transcode'
          app[:transcode] = false

        when '--drop-subs'
          app[:drop_subs] = true

        when '--no-drop-subs'
          app[:drop_subs] = false

        when '--suffix'
          app[:suffix] = validate_arg_value(args[0], args[1])

        when '--undefined-language'
          app[:suffix] = validate_arg_value(args[0], args[1])

        when '--no-fix-undefined-language'
          app[:fix_undefined_language] = false

        when '--fix-undefined-language'
          app[:fix_undefined_language] = true

        #-----------------------
        # Quality
        #-----------------------

        when '--no-quality-reports'
          app[:quality_reports] = false

        when '--quality-reports'
          app[:quality_reports] = true

        when '--min-width'
          app[:min_width] = validate_arg_value(args[0], args[1])

        when '--min-channels'
          app[:min_channels] = validate_arg_value(args[0], args[1])

        #-----------------------
        # Other
        #-----------------------

        else

          # An unknown parameter was encountered, so let's stop everything.
          if args[0] =~ /^--.*$/
            print_arg_error("Error: option #{c.bold(args[0])} was specified, but I don't know that that means.")
          end

          # Otherwise, check for existence of the path, and warn or proceed.
          path = File.expand_path(args[0])
          if File.exist?(path)
            app.run(path)
          else
            puts "Note: skipping #{c.bold(path)}, which seems not to exist."
          end

        end # case

        args.shift

      end # while

      # If path has never been set, then the user didn't specify anything to check,
      # which is likely to be a mistake.
      unless path
        print_arg_error("You did not specify any input file(s) or directory(s). Use #{c.bold(File.basename($0))} for help.")
      end

    end # run_cli


    #------------------------------------------------------------
    # Displays an argument error message and exits the program.
    # ------------------------------------------------------------
    def print_arg_error(message)
      width = [TTY::Screen.width, 61].max - 1
      STDERR.puts hanging_string(string: message, hang: 3, margin: width)
      exit 1
    end


    #------------------------------------------------------------
    # Perform a really simple validation of the given value for
    # the given argument, returning the value if successful.
    # ------------------------------------------------------------
    def validate_arg_value(arg, value)
      if !value
        print_arg_error("Error: option #{c.bold(arg)} was specified, but no value was given.")
      elsif value =~ /^-.*$/
        print_arg_error("Error: option #{c.bold(arg)} was specified, but the value #{c.bold(value)} looks like another option argument.")
      end
      value
    end


  end # class MmToolCli
end # module MmToolCliModule


###########################################################
# Main
###########################################################

cli = MmTool::MmToolCli.new(MmTool::ApplicationMain.sharedApplication)
cli.run(ARGV)
