#!/usr/bin/env ruby

require_relative '../lib/mm_tool'

module MmTool

  require 'tty-command'
  require 'tty-which'

  #=============================================================================
  # The MmToolCli class implements the command line interface for
  # MmTool::ApplicationMain
  #=============================================================================
  class MmToolCli

    include MmToolConsoleOutputHelpers

    #------------------------------------------------------------
    # Designated initializer.
    #------------------------------------------------------------
    def initialize(app_instance = MmTool::ApplicationMain.shared_application)
      @app    = app_instance
    end

    #------------------------------------------------------------
    # Property accessor
    #------------------------------------------------------------
    def app
      @app
    end

    #------------------------------------------------------------
    # Print Help
    #------------------------------------------------------------
    #noinspection RubyResolve
    def print_help
      # Gather the basic dimensions required for output.
      # Support a minimum width of 60, which is reasonable, and
      # allow enough room to spacing around the longest argument.
      width    = [TTY::Screen.width, 61].max - 1
      hang_arg = longest_arg_length(app)

      header = <<~HEREDOC
        #{c.bold('Usage:')} #{File.basename($0)} [options...] <directory|file> [options...] <directory|file> ...
        
        Performs media analysis and reports on files that don't meet quality requirements and/or files that
        have containers and/or streams of undesired types. Files with undesired containers and/or streams
        can optionally be transcoded into a new file.
        
        You must specify a file or a directory. Specifying a directory implies a recursive search for files
        matching the #{c.bold('--container-extension')} option.
  
        Options and files are processed as they occur, and remain in effect for subsequent input files until
        encountered again with a different value. Boolean flags shown below modify default behavior. They
        can be undone for subsequent input files with the capitalized version of the short flag, or by adding
        or deleting #{c.bold('no-')} for the verbose argument form.
      HEREDOC

      puts hanging_string(string: header, hang: 3, margin: width)

      argument_groups(app).each do |group|

        puts "\n#{c.bold(group)}\n\n"

        app.options.select { |option| app.options[option][:help_group] == group }
            .each do | argument, attributes |

          arg = "#{format_argument(attributes, hang_arg)}#{attributes[:help_desc]}" % format_value(app[argument])
          puts hanging_string(string: arg, hang: hang_arg, margin: width) + "\n"

        end # do
      end # each group
    end # print_help

    #------------------------------------------------------------
    # Validate pre-requisites.
    #------------------------------------------------------------
    #noinspection RubyResolve
    def validate_prerequisites
      commands = %w(ffmpeg)
      codecs   = %w(libx264 libx265 libfdk_aac)
      task     = TTY::Command.new(printer: :null)
      success  = true

      # We'll check everything in items before failing, so that we can provide
      # a comprehensive list to the user. No one wants to see what's missing
      # on-by-one.
      commands.each do |command|
        unless TTY::Which.exist?(command)
          print_error("Error: #{c.bold(command)} is not installed (or not in your #{c.bold('$PATH')}).")
          success = no
        end
      end
      exit 1 unless success

      # Now we'll make sure that all of the codecs that we're interested in
      # are installed as part of ffmpeg. This is necessary because not every
      # binary distribution supports non-free.

      # Again, we'll check them all before failing in order to list everything.
      codecs.each do |codec|
        result = task.run!("ffprobe -v quiet -codecs | grep #{codec}")
        print_error("Error: ffmpeg was built without support for the #{c.bold(codec)} codec, which is required.") if result.failure?
        success = success && result.success?
      end
      exit 1 unless success
    end

    #------------------------------------------------------------
    # Run the CLI.
    #------------------------------------------------------------
    #noinspection RubyResolve
    def run(args)

      path = nil
      while args.count > 0 do

        # Convert single hyphen arguments to one or more multi-hyphen
        # arguments. Doing this as an extra step eliminates redundancy,
        # but also allows -abc in place of -a -b -c.
        if args[0] =~ /^-[A-Za-z]+$/

          args[0][1..-1].reverse.each_char do |char|

            case char

            when 'h'
              args.insert(1, "--help")
            when 'i'
              args.insert(1, "--no-info-header")
            when 'I'
              args.insert(1, '--info-header')
            when 't'
              args.insert(1, "--transcode")
            when 'T'
              args.insert(1, "--no-transcode")
            when 'u'
              args.insert(1, "--no-fix-undefined-language")
            when 'U'
              args.insert(1, "--fix-undefined-language")
            when 'p'
              args.insert(1, "--dump")
            when 'P'
              args.insert(1, "--no-dump")
            else
              print_error_and_exit("Error: option #{c.bold(args[0])} was specified, but I don't know what that means.")
            end

          end

          args.shift
          next
        end

        # The main loop processes options, commands, and files in first-in,
        # first out order, which is the normal Unix way compared to how
        # Ruby scripts try to handle things.
        case args[0]

        #-----------------------
        # Main Options
        #-----------------------

        when '--help'
          self.print_help
          exit 0

        when '--containers'
          app[:container_files] = validate_arg_value(args[0], args[1]).split(',')
          args.shift

        when '--scan'
          value = validate_arg_value(args[0], args[1]).downcase
          unless %w(normal all flagged quality force).include?(value)
            print_error("Note: value #{c.bold(value)} doesn't make sense; assuming #{c.bold('normal')}.")
            value = 'normal'
          end
          app[:scan_type] = value
          args.shift

        when '--no-info-header'
          app[:info_header] = false

        when '--info-header'
          app[:info_header] = true

        when '--ignore-files'
          app[:ignore_files] = true

        when '--no-ignore-files'
          app[:ignore_files] = false

        when '--unignore-files'
          app[:unignore_files] = true

        when '--no-unignore-files'
          app[:unignore_files] = false

        when '--version'
          puts "#{File.basename $0}, version #{MmTool::VERSION}"

        when '--dump'
          app[:dump] = true

        when '--no-dump'
          app[:dump] = false

        when '--'
          break

        #-----------------------
        # Media
        #-----------------------

        when '--containers-preferred'
          app[:containers_preferred] = validate_arg_value(args[0], args[1]).split(',')
          args.shift

        when '--codecs-audio-preferred'
          app[:codec_audio_preferred] = validate_arg_value(args[0], args[1]).split(',')
          args.shift

        when '--codecs-video-preferred'
          app[:codec_video_preferred] = validate_arg_value(args[0], args[1]).split(',')
          args.shift

        when '--codecs-subs-preferred'
          app[:codec_subs_preferred] = validate_arg_value(args[0], args[1]).split(',')
          args.shift

        when '--keep-langs-audio'
          app[:keep_langs_audio] = validate_arg_value(args[0], args[1]).split(',')
          args.shift

        when '--keep_langs_video'
          app[:keep_langs_video] = validate_arg_value(args[0], args[1]).split(',')
          args.shift

        when '--keep-langs-subs'
          app[:keep_langs_subs] = validate_arg_value(args[0], args[1]).split(',')
          args.shift

        #-----------------------
        # Transcoding
        #-----------------------

        when '--transcode'
          app[:ignore_files] = false
          app[:unignore_files] = false
          app[:transcode] = true

        when '--no-transcode'
          app[:transcode] = false
          app.tempfile = nil

        when '--no-drop-subs'
          app[:drop_subs] = false

        when '--suffix'
          app[:suffix] = validate_arg_value(args[0], args[1])

        when '--undefined-language'
          app[:suffix] = validate_arg_value(args[0], args[1])

        when '--no-fix-undefined-language'
          app[:fix_undefined_language] = false

        when '--fix-undefined-language'
          app[:fix_undefined_language] = true

        #-----------------------
        # Quality
        #-----------------------

        when '--min-width'
          app[:min_width] = validate_arg_value(args[0], args[1])

        when '--min-channels'
          app[:min_channels] = validate_arg_value(args[0], args[1])

        #-----------------------
        # Other
        #-----------------------

        else

          # An unknown parameter was encountered, so let's stop everything.
          if args[0] =~ /^--.*$/
            print_error_and_exit("Error: option #{c.bold(args[0])} was specified, but I don't know what that means.")
          end

          # Otherwise, check for existence of the path, and warn or proceed.
          path = File.expand_path(args[0])
          if File.exist?(path)
            app.run(path)
          else
            print_error("Note: skipping #{c.bold(path)}, which seems not to exist.")
          end

        end # case

        args.shift

      end # while

      # If path has never been set, then the user didn't specify anything to check,
      # which is likely to be a mistake.
      unless path
        print_error_and_exit("You did not specify any input file(s) or directory(s). Use #{c.bold(File.basename($0))} for help.")
      end

    end # run_cli

    #------------------------------------------------------------
    # Perform a really simple validation of the given value for
    # the given argument, returning the value if successful.
    # ------------------------------------------------------------
    #noinspection RubyResolve
    def validate_arg_value(arg, value)
      if !value
        print_error_and_exit("Error: option #{c.bold(arg)} was specified, but no value was given.")
      elsif value =~ /^-.*$/
        print_error_and_exit("Error: option #{c.bold(arg)} was specified, but the value #{c.bold(value)} looks like another option argument.")
      end
      value
    end # validate_arg_value

  end # class MmToolCli
end # module MmToolCliModule


###########################################################
# Main
###########################################################

cli = MmTool::MmToolCli.new(MmTool::ApplicationMain.shared_application)
cli.validate_prerequisites
cli.run(ARGV)
