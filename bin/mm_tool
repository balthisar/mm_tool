#!/usr/bin/env ruby

################################################################################
# MmToolCli
#  This file constitutes the command line interface for mm_tool.
###############################################################################

require 'fileutils'
require_relative '../lib/mm_tool'


module MmTool

  #=============================================================================
  # The MmToolCli class implements the command line interface for
  # MmTool::ApplicationMain
  #=============================================================================
  class MmToolCli

    include MmToolConsoleOutputHelpers

    #------------------------------------------------------------
    # Designated initializer.
    #------------------------------------------------------------
    def initialize(app_instance = MmTool::ApplicationMain.sharedApplication)
      @app    = app_instance
    end


    #------------------------------------------------------------
    # Property accessor
    #------------------------------------------------------------
    def app
      @app
    end


    #------------------------------------------------------------
    # Print Help
    #------------------------------------------------------------
    def print_help
      # Gather the basic dimensions required for output.
      # Support a minimum width of 60, which is reasonable, and
      # allow enough room to spacing around the longest argument.
      width    = [TTY::Screen.width, 61].max - 1
      hang_arg = longest_arg_length(app)

      header = <<~HEREDOC
        #{c.bold('Usage:')} #{File.basename($0)} [options...] <directory|file> [options...] <directory|file> ...
        
        Peforms media analysis and reports on files that don't meet quality requirements and/or files that
        have containers and/or streams of undesired types. Files with undesired containers and/or streams
        can optionally be transcoded into a new file.
        
        You must specify a file or a directory. Specifying a directory implies a recursive search for files
        matching the #{c.bold('--container-extension')} option.
  
        Options and files are processed as they occur, and remain in effect for subsequent input files until
        encountered again with a different value. Boolean flags shown below modify default behavior. They
        can be undone for subsequent input files with the capitalized version of the short flag, or by adding
        or deleting #{c.bold('no-')} for the verbose argument form.
      HEREDOC

      puts hanging_string(string: header, hang: 3, margin: width)

      argument_groups(app).each do |group|

        puts "\n#{c.bold(group)}\n\n"

        app.options.select { |option| app.options[option][:help_group] == group }
            .each do | argument, attributes |

          arg = "#{format_argument(attributes, hang_arg)}#{attributes[:help_desc]}" % format_value(app[argument])
          puts hanging_string(string: arg, hang: hang_arg, margin: width) + "\n"

        end # do
      end # each group
    end # print_help


    #------------------------------------------------------------
    # Validate pre-requisites.
    #------------------------------------------------------------
    def validate_prerequisites

      item_list = %w(ffmpeg xmllint)

      item_list = %w(libx264 libx265 libfdk_aac)


    end


    #------------------------------------------------------------
    # Run the CLI.
    #------------------------------------------------------------
    def run(args)

      path = nil
      while args.count > 0 do

        # Convert single hyphen arguments to one or more multi-hyphen
        # arguments. Doing this as an extra step eliminates redundancy,
        # but also allows -abc in place of -a -b -c.
        if args[0] =~ /^-[A-Za-z]+$/

          args[0][1..-1].reverse.each_char do |char|

            case char

            when "h"
              args.insert(1, "--help")
            when "d"
              args.insert(1, "--drop-subs")
            when "D"
              args.insert(1, "--no-drop-subs")
            when "s"
              args.insert(1, "--skip-boring-files")
            when "S"
              args.insert(1, "--no-skip-boring-files")
            when "t"
              args.insert(1, "--transcode")
            when "T"
              args.insert(1, "--no-transcode")
            when "u"
              args.insert(1, "--no-fix-undefined-language")
            when "U"
              args.insert(1, "--fix-undefined-language")
            when "v"
              args.insert(1, "--verbose")
            when "V"
              args.insert(1, "--no-verbose")
            when "w"
              args.insert(1, "--no-quality-reports ")
            when "W"
              args.insert(1, "--quality-reports ")
            when "x"
              args.insert(1, "--xml")
            when "X"
              args.insert(1, "--no-xml")
            else
              print_error_and_exit("Error: option #{c.bold(args[0])} was specified, but I don't know what that means.")
            end

          end

          args.shift
          next
        end


        # The main loop processes options, commands, and files in first-in,
        # first out order, which is the normal Unix way compared to how
        # Ruby scripts try to handle things.
        case args[0]


        #-----------------------
        # Main Options
        #-----------------------

        when '--help'
          self.print_help
          exit 0

        when '--containers'
          app[:container_files] = validate_arg_value(args[0], args[1]).split(',')
          args.shift

        when '--skip-boring-files'
          app[:skip_boring] = true

        when '--no-skip-boring-files'
          app[:skip_boring] = false

        when '--verbose'
          app[:verbose] = true

        when '--no-verbose'
          app[:verbose] = false

        when '--version'
          puts "#{File.basename $0}, version #{MmTool::VERSION}"

        when '--xml'
          app[:xml] = true

        when '--no-xml'
          app[:xml] = false

        when '--'
          break

        #-----------------------
        # Media
        #-----------------------

        when '--containers-preferred'
          app[:containers_preferred] = validate_arg_value(args[0], args[1]).split(',')
          args.shift

        when '--codec-audio-preferred'
          app[:codec_audio_preferred] = validate_arg_value(args[0], args[1]).split(',')
          args.shift

        when '--codec-video-preferred'
          app[:codec_video_preferred] = validate_arg_value(args[0], args[1]).split(',')
          args.shift

        when '--codec-subs-preferred'
          app[:codec_subs_preferred] = validate_arg_value(args[0], args[1]).split(',')
          args.shift

        when '--keep-langs-audio'
          app[:keep_langs_audio] = validate_arg_value(args[0], args[1]).split(',')
          args.shift

        when '--keep_langs_video'
          app[:keep_langs_video] = validate_arg_value(args[0], args[1]).split(',')
          args.shift

        when '--keep-langs-subs'
          app[:keep_langs_subs] = validate_arg_value(args[0], args[1]).split(',')
          args.shift

        #-----------------------
        # Transcoding
        #-----------------------

        when '--transcode'
          app[:transcode] = true

        when '--no-transcode'
          app[:transcode] = false

        when '--drop-subs'
          app[:drop_subs] = true

        when '--no-drop-subs'
          app[:drop_subs] = false

        when '--suffix'
          app[:suffix] = validate_arg_value(args[0], args[1])

        when '--undefined-language'
          app[:suffix] = validate_arg_value(args[0], args[1])

        when '--no-fix-undefined-language'
          app[:fix_undefined_language] = false

        when '--fix-undefined-language'
          app[:fix_undefined_language] = true

        #-----------------------
        # Quality
        #-----------------------

        when '--no-quality-reports'
          app[:quality_reports] = false

        when '--quality-reports'
          app[:quality_reports] = true

        when '--min-width'
          app[:min_width] = validate_arg_value(args[0], args[1])

        when '--min-channels'
          app[:min_channels] = validate_arg_value(args[0], args[1])

        #-----------------------
        # Other
        #-----------------------

        else

          # An unknown parameter was encountered, so let's stop everything.
          if args[0] =~ /^--.*$/
            print_error_and_exit("Error: option #{c.bold(args[0])} was specified, but I don't know what that means.")
          end

          # Otherwise, check for existence of the path, and warn or proceed.
          path = File.expand_path(args[0])
          if File.exist?(path)
            app.run(path)
          else
            print_error("Note: skipping #{c.bold(path)}, which seems not to exist.")
          end

        end # case

        args.shift

      end # while

      # If path has never been set, then the user didn't specify anything to check,
      # which is likely to be a mistake.
      unless path
        print_error_and_exit("You did not specify any input file(s) or directory(s). Use #{c.bold(File.basename($0))} for help.")
      end

    end # run_cli


    #------------------------------------------------------------
    # Perform a really simple validation of the given value for
    # the given argument, returning the value if successful.
    # ------------------------------------------------------------
    def validate_arg_value(arg, value)
      if !value
        print_error_and_exit("Error: option #{c.bold(arg)} was specified, but no value was given.")
      elsif value =~ /^-.*$/
        print_error_and_exit("Error: option #{c.bold(arg)} was specified, but the value #{c.bold(value)} looks like another option argument.")
      end
      value
    end


  end # class MmToolCli
end # module MmToolCliModule


###########################################################
# Main
###########################################################

cli = MmTool::MmToolCli.new(MmTool::ApplicationMain.sharedApplication)
cli.run(ARGV)
