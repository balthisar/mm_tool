#!/usr/bin/env ruby

################################################################################
# MmToolCli
#  This file constitutes the command line interface for mm_tool.
################################################################################

require 'fileutils'
require 'tty-screen'
require 'tty-table'
require 'pastel'
require_relative '../lib/mm_tool'


module MmToolCli

  @@app = MmTool::ApplicationMain.sharedApplication
  @@p = Pastel.new(enabled: $stdout.tty? && $stderr.tty?)


  #======================================================
  # Print Help
  #======================================================
  def self.print_help(*args)
    width = TTY::Screen.width - 1
    hang_arg = self.longest_arg_length + 6
    header = <<~HEREDOC
      #{@@p.bold('Usage:')} #{File.basename $0} [options...] <directory|file> [options...] <directory|file> ...
      
      Peforms media analysis and reports on files that don't meet quality requirements and/or files that
      have containers and/or streams of undesired types. Files with undesired containers and/or streams
      can optionally be transcoded into a new file.
      
      You must specify a file or a directory. Specifying a directory implies a recursive search for files
      matching the #{@@p.bold('--container-extension')} option.

      Options and file are processed as they occur, and remain in effect for subsequent input files until
      encountered again with a different value.
    HEREDOC

    puts self.hanging_string(string: header, hang: 3, margin: width)

    self.groups_array.each do |group|

      puts "\n#{@@p.bold(group)}\n\n"

      @@app.options.select { |option| @@app.options[option][:help_group] == group }
          .each do | argument, attributes |

        s = attributes[:arg_short]
        l = attributes[:arg_long]
        f = attributes[:arg_format]
        d = attributes[:help_desc]

        a = "     #{l}"
        if s && f
          a = " #{s}, #{l} #{f}"
        elsif s
          a = " #{s}, #{l}"
        elsif f
          a = "     #{l} #{f}"
        end
        a = a + " " * (hang_arg - a.length)

        arg = "#{a}#{d}" % @@app[argument].to_s

        puts self.hanging_string(string: arg, hang: hang_arg, margin: width) + "\n"


      end




      #@@app.options.collect { |option| option[1] }
      #    .select { |attribute| attribute[:help_group] == group }
      #    .each do |attributes|
      #
      #  s = attributes[:arg_short]
      #  l = attributes[:arg_long]
      #  f = attributes[:arg_format]
      #  d = attributes[:help_desc]
      #
      #  a = "     #{l}"
      #  if s && f
      #    a = " #{s}, #{l} #{f}"
      #  elsif s
      #    a = " #{s}, #{l}"
      #  elsif f
      #    a = "     #{l} #{f}"
      #  end
      #  a = a + " " * (hang_arg - a.length)
      #
      #  #arg = "#{a}#{d}" % @@app[]
      #
      #  puts self.hanging_string(string: arg, hang: hang_arg, margin: width) + "\n"
      #
      #end # do |attributes|


    end # each group




  end


  #======================================================
  # Get an array of argument groups.
  #======================================================
  def self.groups_array
    @@app.options.collect { |i| i[1] }
        .collect { |i| i[:help_group] }
        .uniq
  end


  #======================================================
  # Find the length of the longest argument label.
  #======================================================
  def self.longest_arg_length
    @@app.options.collect { |i| i[1] }
        .collect { |i| "#{i[:arg_short]}, #{i[:arg_long]} #{i[:arg_format]}".length }
        .max
  end


  #======================================================
  # Return a string: with a hanging indent of hang: and a
  # right margin of margin:.
  #======================================================
  def self.hanging_string( string:, hang: 0, margin: 78 )
    indent_spaces = " " * hang
    result = []

    # Each individual paragraph should end with two newlines; therefore convert
    # individual newlines into spaces, and break the paragraphs into a split.
    string.gsub(/\n\n/, "\f").gsub(/\n/, " ").split(/\f/).each do |line|

      buffer = ''

      samp = line.split(/\s/)

      line.split(/\s/).each do |word|

        word = ' ' if word.length == 0

        len_buffer = buffer.gsub(/\e\[([;\d]+)?m/, '').length

        if len_buffer == 0 || buffer[-1] == ' '
          added_word = word
        else
          added_word = ' ' + word
        end

        len_word = added_word.gsub(/\e\[([;\d]+)?m/, '').length

        width = result.count == 0 ? margin : margin - hang

        if len_buffer + len_word <= width
          buffer = buffer + added_word
        else
          if result.count == 0
            result << buffer + "\n"
          else
            result << indent_spaces + buffer + "\n"
          end
          buffer = word
        end

      end # line

      if result.count == 0
        result << buffer + "\n\n"
      else
        result << indent_spaces + buffer + "\n\n"
      end

    end

    result.join[0...-1]
  end

end # module MmToolCli


###########################################################
# Main
###########################################################

MmToolCli.print_help(ARGV)

